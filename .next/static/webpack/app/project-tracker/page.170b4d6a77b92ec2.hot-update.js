"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/project-tracker/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiService: () => (/* binding */ apiService)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(app-pages-browser)/./lib/config.ts\");\n\nconst API_BASE_URL = _config__WEBPACK_IMPORTED_MODULE_0__.config.getApiUrl();\n// Helper function for development-only logging\nconst devLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.features.enableDebugLogging) {\n        console.log(...args);\n    }\n};\n// Helper function for development-only error logging\nconst devError = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.features.enableDebugLogging) {\n        console.error(...args);\n    }\n};\nclass ApiService {\n    getAuthHeader() {\n        console.log('getAuthHeader');\n        const stored = localStorage.getItem('token') || '';\n        const authValue = stored ? stored.startsWith('Bearer ') ? stored : \"Bearer \".concat(stored) : '';\n        return {\n            'Content-Type': 'application/json',\n            ...authValue && {\n                'Authorization': authValue\n            }\n        };\n    }\n    async handleResponse(response) {\n        devLog('API Response Status:', response.status);\n        devLog('API Response OK:', response.ok);\n        devLog('API Response Headers:', Object.fromEntries(response.headers.entries()));\n        if (!response.ok) {\n            let errorMessage = 'API request failed';\n            try {\n                const errorData = await response.json();\n                devLog('API Error Data:', errorData);\n                errorMessage = errorData.message || errorData.error || errorData.msg || 'API request failed';\n            } catch (parseError) {\n                devLog('Failed to parse error response:', parseError);\n                const errorText = await response.text();\n                devLog('Raw error response:', errorText);\n                errorMessage = errorText || 'API request failed';\n            }\n            // If token invalid/expired, clear storage to force re-login\n            if (response.status === 401 || /token/i.test(errorMessage || '')) {\n                try {\n                    localStorage.removeItem('token');\n                    localStorage.removeItem('currentUser');\n                } catch (e) {}\n            }\n            throw new Error(errorMessage);\n        }\n        try {\n            const data = await response.json();\n            devLog('API Success Response:', data);\n            return data;\n        } catch (parseError) {\n            devLog('Failed to parse success response:', parseError);\n            throw new Error('Failed to parse API response');\n        }\n    }\n    // Authentication APIs\n    async register(userData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/register\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(userData)\n        });\n        return this.handleResponse(response);\n    }\n    async login(credentials) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/login\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(credentials)\n        });\n        return this.handleResponse(response);\n    }\n    async getProfile() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/profile\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async updateProfile(data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/profile\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    // User APIs\n    async getUsers() {\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users\"), {\n                headers: this.getAuthHeader()\n            });\n            const data = await this.handleResponse(response);\n            devLog('API Service - getUsers response:', data);\n            return Array.isArray(data) ? data : [];\n        } catch (error) {\n            devError('API Service - getUsers error:', error);\n            throw error;\n        }\n    }\n    async getUserById(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users/\").concat(id), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // New RBAC helper endpoints\n    async getAssignableUsers() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users/helpers/assignable-users\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getMyTeam() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users/helpers/my-team\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Project APIs\n    async getProjects(params) {\n        const query = new URLSearchParams();\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined) query.append(key, value.toString());\n            });\n        }\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects?\").concat(query.toString()), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectById(id) {\n        try {\n            const url = \"\".concat(API_BASE_URL, \"/api/projects/\").concat(id);\n            const headers = this.getAuthHeader();\n            console.log('getProjectById - URL:', url);\n            console.log('getProjectById - Headers:', headers);\n            console.log('getProjectById - Authorization header:', headers.Authorization);\n            const response = await fetch(url, {\n                headers: headers\n            });\n            console.log('getProjectById - Response status:', response.status);\n            console.log('getProjectById - Response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('getProjectById - Error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            console.log('getProjectById - Success result:', result);\n            return result;\n        } catch (error) {\n            console.error('getProjectById - Error:', error);\n            throw error;\n        }\n    }\n    async createProject(projectData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects\"), {\n            method: 'POST',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(projectData)\n        });\n        return this.handleResponse(response);\n    }\n    async updateProject(id, projectData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(id), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(projectData)\n        });\n        return this.handleResponse(response);\n    }\n    async deleteProject(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectTasks(projectId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/tasks\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Team Member Management APIs\n    async addTeamMember(projectId, userId) {\n        let role = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'member';\n        devLog('API Service - addTeamMember called with:', {\n            projectId,\n            userId,\n            role\n        });\n        devLog('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members\"));\n        devLog('API Service - Headers:', this.getAuthHeader());\n        devLog('API Service - Request Body:', JSON.stringify({\n            userId,\n            role\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    userId,\n                    role\n                })\n            });\n            devLog('API Service - addTeamMember response status:', response.status);\n            devLog('API Service - addTeamMember response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - addTeamMember error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            devLog('API Service - addTeamMember success result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - addTeamMember error:', error);\n            throw error;\n        }\n    }\n    async removeTeamMember(projectId, userId) {\n        devLog('API Service - removeTeamMember called with:', {\n            projectId,\n            userId\n        });\n        devLog('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId));\n        devLog('API Service - Headers:', this.getAuthHeader());\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId), {\n                method: 'DELETE',\n                headers: this.getAuthHeader()\n            });\n            devLog('API Service - removeTeamMember response status:', response.status);\n            devLog('API Service - removeTeamMember response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - removeTeamMember error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            devLog('API Service - removeTeamMember success result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - removeTeamMember error:', error);\n            throw error;\n        }\n    }\n    async updateTeamMemberRole(projectId, userId, role) {\n        devLog('API Service - updateTeamMemberRole called with:', {\n            projectId,\n            userId,\n            role\n        });\n        devLog('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId));\n        devLog('API Service - Headers:', this.getAuthHeader());\n        devLog('API Service - Request Body:', JSON.stringify({\n            role\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId), {\n                method: 'PUT',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    role\n                })\n            });\n            devLog('API Service - updateTeamMemberRole response status:', response.status);\n            devLog('API Service - updateTeamMemberRole response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - updateTeamMemberRole error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            devLog('API Service - updateTeamMemberRole success result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - updateTeamMemberRole error:', error);\n            throw error;\n        }\n    }\n    async bulkAddTeamMembers(projectId, teamMembers) {\n        devLog('API Service - bulkAddTeamMembers called with:', {\n            projectId,\n            teamMembers\n        });\n        devLog('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/bulk\"));\n        devLog('API Service - Headers:', this.getAuthHeader());\n        devLog('API Service - Request Body:', JSON.stringify({\n            teamMembers\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/bulk\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    teamMembers\n                })\n            });\n            devLog('API Service - bulkAddTeamMembers response status:', response.status);\n            devLog('API Service - bulkAddTeamMembers response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - bulkAddTeamMembers error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            devLog('API Service - bulkAddTeamMembers success result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - bulkAddTeamMembers error:', error);\n            throw error;\n        }\n    }\n    // Fallback method using project update API\n    async addTeamMembersViaProjectUpdate(projectId, userIds) {\n        devLog('API Service - addTeamMembersViaProjectUpdate called with:', {\n            projectId,\n            userIds\n        });\n        try {\n            // First get the current project data\n            const currentProject = await this.getProjectById(projectId);\n            devLog('API Service - Current project data:', currentProject);\n            // Get current teamMembers array (not assignedTo)\n            const currentTeamMembers = currentProject.teamMembers || [];\n            devLog('API Service - Current teamMembers:', currentTeamMembers);\n            // Extract existing user IDs from teamMembers (handle both direct user objects and nested user objects)\n            const existingUserIds = currentTeamMembers.map((item)=>{\n                if (item && typeof item === 'object') {\n                    if (item.user && item.user._id) {\n                        return item.user._id; // Nested user object\n                    } else if (item._id) {\n                        return item._id; // Direct user object\n                    }\n                }\n                return null;\n            }).filter((id)=>id !== null);\n            devLog('API Service - Existing team member user IDs:', existingUserIds);\n            // Add new user IDs to the array (avoiding duplicates)\n            const updatedUserIds = [\n                ...new Set([\n                    ...existingUserIds,\n                    ...userIds\n                ])\n            ];\n            devLog('API Service - Updated user IDs:', updatedUserIds);\n            // Create teamMembers array with proper structure for backend\n            const updatedTeamMembers = updatedUserIds.map((userId)=>({\n                    user: userId,\n                    role: 'member' // default role\n                }));\n            // Update the project with new teamMembers array\n            const updateData = {\n                ...currentProject,\n                teamMembers: updatedTeamMembers\n            };\n            devLog('API Service - Update data:', updateData);\n            const result = await this.updateProject(projectId, updateData);\n            devLog('API Service - Project update result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - addTeamMembersViaProjectUpdate error:', error);\n            throw error;\n        }\n    }\n    async removeTeamMemberViaProjectUpdate(projectId, userId) {\n        devLog('API Service - removeTeamMemberViaProjectUpdate called with:', {\n            projectId,\n            userId\n        });\n        try {\n            // First get the current project data\n            const currentProject = await this.getProjectById(projectId);\n            devLog('API Service - Current project data:', currentProject);\n            // Get current teamMembers array (not assignedTo)\n            const currentTeamMembers = currentProject.teamMembers || [];\n            devLog('API Service - Current teamMembers before removal:', currentTeamMembers);\n            devLog('API Service - Current teamMembers count before removal:', currentTeamMembers.length);\n            // Log each team member for debugging\n            currentTeamMembers.forEach((member, index)=>{\n                const memberUserId = typeof member.user === 'string' ? member.user : member.user._id;\n                devLog(\"API Service - Team member \".concat(index, \":\"), {\n                    member,\n                    memberUserId,\n                    shouldRemove: memberUserId === userId\n                });\n            });\n            // Remove ONLY the specific user ID from the teamMembers array\n            const updatedTeamMembers = currentTeamMembers.filter((item)=>{\n                if (item && typeof item === 'object' && item.user) {\n                    const itemUserId = typeof item.user === 'string' ? item.user : item.user._id;\n                    const shouldKeep = itemUserId !== userId;\n                    devLog(\"API Service - Filtering team member: \".concat(itemUserId, \" !== \").concat(userId, \" = \").concat(shouldKeep));\n                    return shouldKeep;\n                }\n                devLog('API Service - Keeping item (no user property):', item);\n                return true;\n            });\n            devLog('API Service - Updated teamMembers after removal:', updatedTeamMembers);\n            devLog('API Service - Updated teamMembers count after removal:', updatedTeamMembers.length);\n            devLog('API Service - Removed count:', currentTeamMembers.length - updatedTeamMembers.length);\n            // Verify we only removed one member\n            if (currentTeamMembers.length - updatedTeamMembers.length !== 1) {\n                devError('API Service - WARNING: Removed more than one team member!');\n                throw new Error('Team member removal failed - removed more than one member');\n            }\n            // Update the project with new teamMembers array\n            const updateData = {\n                ...currentProject,\n                teamMembers: updatedTeamMembers\n            };\n            devLog('API Service - Update data:', updateData);\n            const result = await this.updateProject(projectId, updateData);\n            devLog('API Service - Project update result:', result);\n            return result;\n        } catch (error) {\n            devError('API Service - removeTeamMemberViaProjectUpdate error:', error);\n            throw error;\n        }\n    }\n    // Task APIs\n    async getTasks(params) {\n        try {\n            const query = new URLSearchParams();\n            if (params) {\n                Object.entries(params).forEach((param)=>{\n                    let [key, value] = param;\n                    if (value !== undefined && value !== '') query.append(key, value);\n                });\n            }\n            const url = \"\".concat(API_BASE_URL, \"/api/tasks\").concat(query.toString() ? \"?\".concat(query.toString()) : '');\n            const response = await fetch(url, {\n                headers: this.getAuthHeader()\n            });\n            const data = await this.handleResponse(response);\n            devLog('API Service - getTasks response:', data);\n            return Array.isArray(data) ? data : [];\n        } catch (error) {\n            devError('API Service - getTasks error:', error);\n            throw error;\n        }\n    }\n    async getTasksByProject(projectId) {\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/tasks\"), {\n                headers: this.getAuthHeader()\n            });\n            return await this.handleResponse(response);\n        } catch (error) {\n            devError('Failed to fetch project tasks:', error);\n            throw error;\n        }\n    }\n    async getTaskById(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async createTask(taskData) {\n        devLog('API Service - createTask called with:', taskData);\n        devLog('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/tasks\"));\n        devLog('API Service - Headers:', this.getAuthHeader());\n        devLog('API Service - Request Body:', JSON.stringify(taskData, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify(taskData)\n            });\n            devLog('API Service - Response status:', response.status);\n            devLog('API Service - Response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - Error response body:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            return this.handleResponse(response);\n        } catch (fetchError) {\n            devError('API Service - Fetch error:', fetchError);\n            throw fetchError;\n        }\n    }\n    async updateTask(id, taskData) {\n        devLog('API Service - updateTask called with ID:', id);\n        devLog('API Service - updateTask data:', taskData);\n        devLog('API Service - updateTask URL:', \"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n                method: 'PUT',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify(taskData)\n            });\n            devLog('API Service - updateTask response status:', response.status);\n            devLog('API Service - updateTask response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                devError('API Service - updateTask error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            return this.handleResponse(response);\n        } catch (error) {\n            devError('API Service - updateTask error:', error);\n            throw error;\n        }\n    }\n    async deleteTask(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async updateTaskStatus(id, status) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id, \"/status\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify({\n                status\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async assignTask(id, assignedTo) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id, \"/assign\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify({\n                assignedTo\n            })\n        });\n        return this.handleResponse(response);\n    }\n    // User Task APIs\n    async getUserTasks(params) {\n        const query = new URLSearchParams();\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined) query.append(key, value);\n            });\n        }\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks?\").concat(query.toString()), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async createUserTask(taskData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks\"), {\n            method: 'POST',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(taskData)\n        });\n        return this.handleResponse(response);\n    }\n    async updateUserTask(id, taskData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks/\").concat(id), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(taskData)\n        });\n        return this.handleResponse(response);\n    }\n    async deleteUserTask(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Dashboard APIs\n    async getDashboardStats() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectsSummary() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/projects-summary\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getTasksSummary() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/tasks-summary\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // New Dashboard Summary API - Single call for all dashboard data\n    async getDashboardSummary(params) {\n        try {\n            const query = new URLSearchParams();\n            if (params === null || params === void 0 ? void 0 : params.department) {\n                query.append('department', params.department);\n            }\n            const url = \"\".concat(API_BASE_URL, \"/api/dashboard/summary\").concat(query.toString() ? \"?\".concat(query.toString()) : '');\n            const response = await fetch(url, {\n                headers: this.getAuthHeader()\n            });\n            return await this.handleResponse(response);\n        } catch (error) {\n            devError('Failed to fetch dashboard summary:', error);\n            throw error;\n        }\n    }\n    // Get available departments for admin users\n    async getDepartments() {\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/departments\"), {\n                headers: this.getAuthHeader()\n            });\n            const data = await this.handleResponse(response);\n            return Array.isArray(data) ? data : [];\n        } catch (error) {\n            devError('Failed to fetch departments:', error);\n            return [];\n        }\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGktc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUVsQyxNQUFNQyxlQUFlRCwyQ0FBTUEsQ0FBQ0UsU0FBUztBQUVyQywrQ0FBK0M7QUFDL0MsTUFBTUMsU0FBUztxQ0FBSUM7UUFBQUE7O0lBQ2pCLElBQUlKLDJDQUFNQSxDQUFDSyxRQUFRLENBQUNDLGtCQUFrQixFQUFFO1FBQ3RDQyxRQUFRQyxHQUFHLElBQUlKO0lBQ2pCO0FBQ0Y7QUFFQSxxREFBcUQ7QUFDckQsTUFBTUssV0FBVztxQ0FBSUw7UUFBQUE7O0lBQ25CLElBQUlKLDJDQUFNQSxDQUFDSyxRQUFRLENBQUNDLGtCQUFrQixFQUFFO1FBQ3RDQyxRQUFRRyxLQUFLLElBQUlOO0lBQ25CO0FBQ0Y7QUE4Q0EsTUFBTU87SUFDSUMsZ0JBQWdCO1FBQ3RCTCxRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNSyxTQUFTQyxhQUFhQyxPQUFPLENBQUMsWUFBWTtRQUNoRCxNQUFNQyxZQUFZSCxTQUNkQSxPQUFPSSxVQUFVLENBQUMsYUFBYUosU0FBUyxVQUFpQixPQUFQQSxVQUNsRDtRQUNKLE9BQU87WUFDTCxnQkFBZ0I7WUFDaEIsR0FBSUcsYUFBYTtnQkFBRSxpQkFBaUJBO1lBQVUsQ0FBQztRQUNqRDtJQUNGO0lBRUEsTUFBY0UsZUFBZUMsUUFBa0IsRUFBRTtRQUMvQ2hCLE9BQU8sd0JBQXdCZ0IsU0FBU0MsTUFBTTtRQUM5Q2pCLE9BQU8sb0JBQW9CZ0IsU0FBU0UsRUFBRTtRQUN0Q2xCLE9BQU8seUJBQXlCbUIsT0FBT0MsV0FBVyxDQUFDSixTQUFTSyxPQUFPLENBQUNDLE9BQU87UUFFM0UsSUFBSSxDQUFDTixTQUFTRSxFQUFFLEVBQUU7WUFDaEIsSUFBSUssZUFBZTtZQUNuQixJQUFJO2dCQUNGLE1BQU1DLFlBQVksTUFBTVIsU0FBU1MsSUFBSTtnQkFDckN6QixPQUFPLG1CQUFtQndCO2dCQUMxQkQsZUFBZUMsVUFBVUUsT0FB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WUFDdkMsT0FBTytCLE1BQU1DLE9BQU8sQ0FBQ2QsUUFBUUEsT0FBTyxFQUFFO1FBQ3hDLEVBQUUsT0FBTzNCLE9BQU87WUFDZEQsU0FBUyxnQ0FBZ0NDO1lBQ3pDLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7QUFDRjtBQUVPLE1BQU1vSCxhQUFhLElBQUluSCxhQUFhIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFN1bWl0IE1pc2hyYVxcT25lRHJpdmUgLSBFY29Tb3VsIEhvbWVcXERvY3VtZW50c1xcUHJvamVjdCB0cmFja2VyclxcUHJvamVjdCB0cmFja2VyXFxsaWJcXGFwaS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gY29uZmlnLmdldEFwaVVybCgpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRldmVsb3BtZW50LW9ubHkgbG9nZ2luZ1xuY29uc3QgZGV2TG9nID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIGlmIChjb25maWcuZmVhdHVyZXMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGV2ZWxvcG1lbnQtb25seSBlcnJvciBsb2dnaW5nXG5jb25zdCBkZXZFcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBpZiAoY29uZmlnLmZlYXR1cmVzLmVuYWJsZURlYnVnTG9nZ2luZykge1xuICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gIH1cbn07XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgZGVwYXJ0bWVudDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVGFzayB7XG4gIF9pZDogc3RyaW5nO1xuICBpZDogc3RyaW5nO1xuICBwcm9qZWN0SWQ6IHN0cmluZztcbiAgdGFzazogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgdGFza1R5cGU/OiBzdHJpbmc7XG4gIHByaW9yaXR5OiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBhc3NpZ25lZFRvOiB7XG4gICAgX2lkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gIH07XG4gIHJlcG9ydGVyOiB7XG4gICAgX2lkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gIH07XG4gIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgZXRhOiBzdHJpbmc7XG4gIGVzdGltYXRlZEhvdXJzPzogbnVtYmVyO1xuICBhY3R1YWxIb3Vycz86IG51bWJlcjtcbiAgcmVtYXJrPzogc3RyaW5nO1xuICByb2FkQmxvY2s/OiBzdHJpbmc7XG4gIHN1cHBvcnROZWVkZWQ/OiBzdHJpbmc7XG4gIGxhYmVscz86IHN0cmluZ1tdO1xuICBhdHRhY2htZW50cz86IHN0cmluZ1tdO1xuICByZWxhdGVkVGFza3M/OiBzdHJpbmdbXTtcbiAgcGFyZW50VGFzaz86IHN0cmluZztcbiAgc3ByaW50Pzogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmNsYXNzIEFwaVNlcnZpY2Uge1xuICBwcml2YXRlIGdldEF1dGhIZWFkZXIoKSB7XG4gICAgY29uc29sZS5sb2coJ2dldEF1dGhIZWFkZXInKTtcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSB8fCAnJztcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBzdG9yZWRcbiAgICAgID8gc3RvcmVkLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSA/IHN0b3JlZCA6IGBCZWFyZXIgJHtzdG9yZWR9YFxuICAgICAgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLihhdXRoVmFsdWUgJiYgeyAnQXV0aG9yaXphdGlvbic6IGF1dGhWYWx1ZSB9KVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlOiBSZXNwb25zZSkge1xuICAgIGRldkxvZygnQVBJIFJlc3BvbnNlIFN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIGRldkxvZygnQVBJIFJlc3BvbnNlIE9LOicsIHJlc3BvbnNlLm9rKTtcbiAgICBkZXZMb2coJ0FQSSBSZXNwb25zZSBIZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnQVBJIHJlcXVlc3QgZmFpbGVkJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgZGV2TG9nKCdBUEkgRXJyb3IgRGF0YTonLCBlcnJvckRhdGEpO1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1zZyB8fCAnQVBJIHJlcXVlc3QgZmFpbGVkJztcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgZGV2TG9nKCdGYWlsZWQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2U6JywgcGFyc2VFcnJvcik7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZGV2TG9nKCdSYXcgZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JUZXh0IHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB0b2tlbiBpbnZhbGlkL2V4cGlyZWQsIGNsZWFyIHN0b3JhZ2UgdG8gZm9yY2UgcmUtbG9naW5cbiAgICAgIGlmIChcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHxcbiAgICAgICAgL3Rva2VuL2kudGVzdChlcnJvck1lc3NhZ2UgfHwgJycpXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndG9rZW4nKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY3VycmVudFVzZXInKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgZGV2TG9nKCdBUEkgU3VjY2VzcyBSZXNwb25zZTonLCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgIGRldkxvZygnRmFpbGVkIHRvIHBhcnNlIHN1Y2Nlc3MgcmVzcG9uc2U6JywgcGFyc2VFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBBUEkgcmVzcG9uc2UnKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRoZW50aWNhdGlvbiBBUElzXG4gIGFzeW5jIHJlZ2lzdGVyKHVzZXJEYXRhOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcGFzc3dvcmQ6IHN0cmluZztcbiAgICByb2xlOiBzdHJpbmc7XG4gICAgZGVwYXJ0bWVudDogc3RyaW5nO1xuICAgIG1hbmFnZXI/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2F1dGgvcmVnaXN0ZXJgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgbG9naW4oY3JlZGVudGlhbHM6IHsgZW1haWw6IHN0cmluZzsgcGFzc3dvcmQ6IHN0cmluZyB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9hdXRoL2xvZ2luYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNyZWRlbnRpYWxzKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb2ZpbGUoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9hdXRoL3Byb2ZpbGVgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2ZpbGUoZGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXBhcnRtZW50Pzogc3RyaW5nIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2F1dGgvcHJvZmlsZWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gVXNlciBBUElzXG4gIGFzeW5jIGdldFVzZXJzKCk6IFByb21pc2U8VXNlcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlcnNgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBnZXRVc2VycyByZXNwb25zZTonLCBkYXRhKTtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBnZXRVc2VycyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRVc2VyQnlJZChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS91c2Vycy8ke2lkfWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gTmV3IFJCQUMgaGVscGVyIGVuZHBvaW50c1xuICBhc3luYyBnZXRBc3NpZ25hYmxlVXNlcnMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS91c2Vycy9oZWxwZXJzL2Fzc2lnbmFibGUtdXNlcnNgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGdldE15VGVhbSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3VzZXJzL2hlbHBlcnMvbXktdGVhbWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gUHJvamVjdCBBUElzXG4gIGFzeW5jIGdldFByb2plY3RzKHBhcmFtcz86IHtcbiAgICBwYWdlPzogbnVtYmVyO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgICBwcmlvcml0eT86IHN0cmluZztcbiAgICBzZWFyY2g/OiBzdHJpbmc7XG4gICAgZGVwYXJ0bWVudD86IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBxdWVyeS5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHM/JHtxdWVyeS50b1N0cmluZygpfWAsXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3RCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtpZH1gO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnZ2V0UHJvamVjdEJ5SWQgLSBVUkw6JywgdXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdnZXRQcm9qZWN0QnlJZCAtIEhlYWRlcnM6JywgaGVhZGVycyk7XG4gICAgICBjb25zb2xlLmxvZygnZ2V0UHJvamVjdEJ5SWQgLSBBdXRob3JpemF0aW9uIGhlYWRlcjonLCBoZWFkZXJzLkF1dGhvcml6YXRpb24pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ2dldFByb2plY3RCeUlkIC0gUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjb25zb2xlLmxvZygnZ2V0UHJvamVjdEJ5SWQgLSBSZXNwb25zZSBvazonLCByZXNwb25zZS5vayk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnZXRQcm9qZWN0QnlJZCAtIEVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdnZXRQcm9qZWN0QnlJZCAtIFN1Y2Nlc3MgcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdnZXRQcm9qZWN0QnlJZCAtIEVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVByb2plY3QocHJvamVjdERhdGE6IHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgcHJpb3JpdHk6IHN0cmluZztcbiAgICBzdGFydERhdGU6IHN0cmluZztcbiAgICBkdWVEYXRlOiBzdHJpbmc7XG4gICAgYXNzaWduZWRUbz86IHN0cmluZ1tdO1xuICAgIHRlYW1NZW1iZXJzPzogQXJyYXk8e1xuICAgICAgdXNlcjogc3RyaW5nO1xuICAgICAgcm9sZTogc3RyaW5nO1xuICAgIH0+O1xuICB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0c2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcm9qZWN0RGF0YSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVQcm9qZWN0KGlkOiBzdHJpbmcsIHByb2plY3REYXRhOiB7XG4gICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgc3RhdHVzPzogc3RyaW5nO1xuICAgIHByaW9yaXR5Pzogc3RyaW5nO1xuICAgIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgICBkdWVEYXRlPzogc3RyaW5nO1xuICAgIGFzc2lnbmVkVG8/OiBzdHJpbmdbXTtcbiAgICB0ZWFtTWVtYmVycz86IEFycmF5PHtcbiAgICAgIHVzZXI6IHN0cmluZztcbiAgICAgIHJvbGU6IHN0cmluZztcbiAgICB9PjtcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcm9qZWN0RGF0YSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBkZWxldGVQcm9qZWN0KGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvamVjdFRhc2tzKHByb2plY3RJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGFza3NgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8vIFRlYW0gTWVtYmVyIE1hbmFnZW1lbnQgQVBJc1xuICBhc3luYyBhZGRUZWFtTWVtYmVyKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nID0gJ21lbWJlcicpIHtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlciBjYWxsZWQgd2l0aDonLCB7IHByb2plY3RJZCwgdXNlcklkLCByb2xlIH0pO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVyc2ApO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBIZWFkZXJzOicsIHRoaXMuZ2V0QXV0aEhlYWRlcigpKTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gUmVxdWVzdCBCb2R5OicsIEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCByb2xlIH0sIG51bGwsIDIpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGVhbS1tZW1iZXJzYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCByb2xlIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIGFkZFRlYW1NZW1iZXIgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlciByZXNwb25zZSBvazonLCByZXNwb25zZS5vayk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyIHN1Y2Nlc3MgcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbW92ZVRlYW1NZW1iZXIocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIHJlbW92ZVRlYW1NZW1iZXIgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHVzZXJJZCB9KTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gVVJMOicsIGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7cHJvamVjdElkfS90ZWFtLW1lbWJlcnMvJHt1c2VySWR9YCk7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIEhlYWRlcnM6JywgdGhpcy5nZXRBdXRoSGVhZGVyKCkpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7cHJvamVjdElkfS90ZWFtLW1lbWJlcnMvJHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSByZW1vdmVUZWFtTWVtYmVyIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIHJlbW92ZVRlYW1NZW1iZXIgcmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlciBlcnJvciByZXNwb25zZTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlciBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlciBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGRhdGVUZWFtTWVtYmVyUm9sZShwcm9qZWN0SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIHJvbGU6IHN0cmluZykge1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUZWFtTWVtYmVyUm9sZSBjYWxsZWQgd2l0aDonLCB7IHByb2plY3RJZCwgdXNlcklkLCByb2xlIH0pO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy8ke3VzZXJJZH1gKTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gSGVhZGVyczonLCB0aGlzLmdldEF1dGhIZWFkZXIoKSk7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIFJlcXVlc3QgQm9keTonLCBKU09OLnN0cmluZ2lmeSh7IHJvbGUgfSwgbnVsbCwgMikpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7cHJvamVjdElkfS90ZWFtLW1lbWJlcnMvJHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByb2xlIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRlYW1NZW1iZXJSb2xlIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRlYW1NZW1iZXJSb2xlIHJlc3BvbnNlIG9rOicsIHJlc3BvbnNlLm9rKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGRldkVycm9yKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRlYW1NZW1iZXJSb2xlIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUZWFtTWVtYmVyUm9sZSBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGVhbU1lbWJlclJvbGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYnVsa0FkZFRlYW1NZW1iZXJzKHByb2plY3RJZDogc3RyaW5nLCB0ZWFtTWVtYmVyczogQXJyYXk8eyB1c2VySWQ6IHN0cmluZzsgcm9sZT86IHN0cmluZyB9Pikge1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBidWxrQWRkVGVhbU1lbWJlcnMgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHRlYW1NZW1iZXJzIH0pO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy9idWxrYCk7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIEhlYWRlcnM6JywgdGhpcy5nZXRBdXRoSGVhZGVyKCkpO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBSZXF1ZXN0IEJvZHk6JywgSlNPTi5zdHJpbmdpZnkoeyB0ZWFtTWVtYmVycyB9LCBudWxsLCAyKSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy9idWxrYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdGVhbU1lbWJlcnMgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIGJ1bGtBZGRUZWFtTWVtYmVycyByZXNwb25zZSBvazonLCByZXNwb25zZS5vayk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBidWxrQWRkVGVhbU1lbWJlcnMgZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIGJ1bGtBZGRUZWFtTWVtYmVycyBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGxiYWNrIG1ldGhvZCB1c2luZyBwcm9qZWN0IHVwZGF0ZSBBUElcbiAgYXN5bmMgYWRkVGVhbU1lbWJlcnNWaWFQcm9qZWN0VXBkYXRlKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWRzOiBzdHJpbmdbXSkge1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyc1ZpYVByb2plY3RVcGRhdGUgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHVzZXJJZHMgfSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGdldCB0aGUgY3VycmVudCBwcm9qZWN0IGRhdGFcbiAgICAgIGNvbnN0IGN1cnJlbnRQcm9qZWN0ID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0QnlJZChwcm9qZWN0SWQpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIEN1cnJlbnQgcHJvamVjdCBkYXRhOicsIGN1cnJlbnRQcm9qZWN0KTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGN1cnJlbnQgdGVhbU1lbWJlcnMgYXJyYXkgKG5vdCBhc3NpZ25lZFRvKVxuICAgICAgY29uc3QgY3VycmVudFRlYW1NZW1iZXJzID0gY3VycmVudFByb2plY3QudGVhbU1lbWJlcnMgfHwgW107XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gQ3VycmVudCB0ZWFtTWVtYmVyczonLCBjdXJyZW50VGVhbU1lbWJlcnMpO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGV4aXN0aW5nIHVzZXIgSURzIGZyb20gdGVhbU1lbWJlcnMgKGhhbmRsZSBib3RoIGRpcmVjdCB1c2VyIG9iamVjdHMgYW5kIG5lc3RlZCB1c2VyIG9iamVjdHMpXG4gICAgICBjb25zdCBleGlzdGluZ1VzZXJJZHMgPSBjdXJyZW50VGVhbU1lbWJlcnMubWFwKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKGl0ZW0udXNlciAmJiBpdGVtLnVzZXIuX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS51c2VyLl9pZDsgLy8gTmVzdGVkIHVzZXIgb2JqZWN0XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLl9pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uX2lkOyAvLyBEaXJlY3QgdXNlciBvYmplY3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5maWx0ZXIoKGlkOiBzdHJpbmcgfCBudWxsKSA9PiBpZCAhPT0gbnVsbCk7XG4gICAgICBcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBFeGlzdGluZyB0ZWFtIG1lbWJlciB1c2VyIElEczonLCBleGlzdGluZ1VzZXJJZHMpO1xuICAgICAgXG4gICAgICAvLyBBZGQgbmV3IHVzZXIgSURzIHRvIHRoZSBhcnJheSAoYXZvaWRpbmcgZHVwbGljYXRlcylcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VySWRzID0gWy4uLm5ldyBTZXQoWy4uLmV4aXN0aW5nVXNlcklkcywgLi4udXNlcklkc10pXTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVcGRhdGVkIHVzZXIgSURzOicsIHVwZGF0ZWRVc2VySWRzKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRlYW1NZW1iZXJzIGFycmF5IHdpdGggcHJvcGVyIHN0cnVjdHVyZSBmb3IgYmFja2VuZFxuICAgICAgY29uc3QgdXBkYXRlZFRlYW1NZW1iZXJzID0gdXBkYXRlZFVzZXJJZHMubWFwKHVzZXJJZCA9PiAoe1xuICAgICAgICB1c2VyOiB1c2VySWQsXG4gICAgICAgIHJvbGU6ICdtZW1iZXInIC8vIGRlZmF1bHQgcm9sZVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIHByb2plY3Qgd2l0aCBuZXcgdGVhbU1lbWJlcnMgYXJyYXlcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgIC4uLmN1cnJlbnRQcm9qZWN0LFxuICAgICAgICB0ZWFtTWVtYmVyczogdXBkYXRlZFRlYW1NZW1iZXJzXG4gICAgICB9O1xuICAgICAgXG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gVXBkYXRlIGRhdGE6JywgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHVwZGF0ZURhdGEpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIFByb2plY3QgdXBkYXRlIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlcnNWaWFQcm9qZWN0VXBkYXRlIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlbW92ZVRlYW1NZW1iZXJWaWFQcm9qZWN0VXBkYXRlKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSByZW1vdmVUZWFtTWVtYmVyVmlhUHJvamVjdFVwZGF0ZSBjYWxsZWQgd2l0aDonLCB7IHByb2plY3RJZCwgdXNlcklkIH0pO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBnZXQgdGhlIGN1cnJlbnQgcHJvamVjdCBkYXRhXG4gICAgICBjb25zdCBjdXJyZW50UHJvamVjdCA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdEJ5SWQocHJvamVjdElkKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBDdXJyZW50IHByb2plY3QgZGF0YTonLCBjdXJyZW50UHJvamVjdCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjdXJyZW50IHRlYW1NZW1iZXJzIGFycmF5IChub3QgYXNzaWduZWRUbylcbiAgICAgIGNvbnN0IGN1cnJlbnRUZWFtTWVtYmVycyA9IGN1cnJlbnRQcm9qZWN0LnRlYW1NZW1iZXJzIHx8IFtdO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIEN1cnJlbnQgdGVhbU1lbWJlcnMgYmVmb3JlIHJlbW92YWw6JywgY3VycmVudFRlYW1NZW1iZXJzKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBDdXJyZW50IHRlYW1NZW1iZXJzIGNvdW50IGJlZm9yZSByZW1vdmFsOicsIGN1cnJlbnRUZWFtTWVtYmVycy5sZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBMb2cgZWFjaCB0ZWFtIG1lbWJlciBmb3IgZGVidWdnaW5nXG4gICAgICBjdXJyZW50VGVhbU1lbWJlcnMuZm9yRWFjaCgobWVtYmVyOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgbWVtYmVyVXNlcklkID0gdHlwZW9mIG1lbWJlci51c2VyID09PSAnc3RyaW5nJyA/IG1lbWJlci51c2VyIDogbWVtYmVyLnVzZXIuX2lkO1xuICAgICAgICBkZXZMb2coYEFQSSBTZXJ2aWNlIC0gVGVhbSBtZW1iZXIgJHtpbmRleH06YCwge1xuICAgICAgICAgIG1lbWJlcixcbiAgICAgICAgICBtZW1iZXJVc2VySWQsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlOiBtZW1iZXJVc2VySWQgPT09IHVzZXJJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgT05MWSB0aGUgc3BlY2lmaWMgdXNlciBJRCBmcm9tIHRoZSB0ZWFtTWVtYmVycyBhcnJheVxuICAgICAgY29uc3QgdXBkYXRlZFRlYW1NZW1iZXJzID0gY3VycmVudFRlYW1NZW1iZXJzLmZpbHRlcigoaXRlbTogYW55KSA9PiB7XG4gICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtLnVzZXIpIHtcbiAgICAgICAgICBjb25zdCBpdGVtVXNlcklkID0gdHlwZW9mIGl0ZW0udXNlciA9PT0gJ3N0cmluZycgPyBpdGVtLnVzZXIgOiBpdGVtLnVzZXIuX2lkO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEtlZXAgPSBpdGVtVXNlcklkICE9PSB1c2VySWQ7XG4gICAgICAgICAgZGV2TG9nKGBBUEkgU2VydmljZSAtIEZpbHRlcmluZyB0ZWFtIG1lbWJlcjogJHtpdGVtVXNlcklkfSAhPT0gJHt1c2VySWR9ID0gJHtzaG91bGRLZWVwfWApO1xuICAgICAgICAgIHJldHVybiBzaG91bGRLZWVwO1xuICAgICAgICB9XG4gICAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBLZWVwaW5nIGl0ZW0gKG5vIHVzZXIgcHJvcGVydHkpOicsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gVXBkYXRlZCB0ZWFtTWVtYmVycyBhZnRlciByZW1vdmFsOicsIHVwZGF0ZWRUZWFtTWVtYmVycyk7XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gVXBkYXRlZCB0ZWFtTWVtYmVycyBjb3VudCBhZnRlciByZW1vdmFsOicsIHVwZGF0ZWRUZWFtTWVtYmVycy5sZW5ndGgpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIFJlbW92ZWQgY291bnQ6JywgY3VycmVudFRlYW1NZW1iZXJzLmxlbmd0aCAtIHVwZGF0ZWRUZWFtTWVtYmVycy5sZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgd2Ugb25seSByZW1vdmVkIG9uZSBtZW1iZXJcbiAgICAgIGlmIChjdXJyZW50VGVhbU1lbWJlcnMubGVuZ3RoIC0gdXBkYXRlZFRlYW1NZW1iZXJzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBXQVJOSU5HOiBSZW1vdmVkIG1vcmUgdGhhbiBvbmUgdGVhbSBtZW1iZXIhJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVhbSBtZW1iZXIgcmVtb3ZhbCBmYWlsZWQgLSByZW1vdmVkIG1vcmUgdGhhbiBvbmUgbWVtYmVyJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvamVjdCB3aXRoIG5ldyB0ZWFtTWVtYmVycyBhcnJheVxuICAgICAgY29uc3QgdXBkYXRlRGF0YSA9IHtcbiAgICAgICAgLi4uY3VycmVudFByb2plY3QsXG4gICAgICAgIHRlYW1NZW1iZXJzOiB1cGRhdGVkVGVhbU1lbWJlcnNcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVcGRhdGUgZGF0YTonLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy51cGRhdGVQcm9qZWN0KHByb2plY3RJZCwgdXBkYXRlRGF0YSk7XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gUHJvamVjdCB1cGRhdGUgcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSByZW1vdmVUZWFtTWVtYmVyVmlhUHJvamVjdFVwZGF0ZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBUYXNrIEFQSXNcbiAgYXN5bmMgZ2V0VGFza3MocGFyYW1zPzogeyBzdGF0dXM/OiBzdHJpbmc7IHRhc2tUeXBlPzogc3RyaW5nOyB2aWV3Pzogc3RyaW5nOyBwcm9qZWN0SWQ/OiBzdHJpbmc7IGFzc2lnbmVkVG8/OiBzdHJpbmc7IGRlcGFydG1lbnQ/OiBzdHJpbmcgfSk6IFByb21pc2U8VGFza1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSAnJykgcXVlcnkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzJHtxdWVyeS50b1N0cmluZygpID8gYD8ke3F1ZXJ5LnRvU3RyaW5nKCl9YCA6ICcnfWA7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gZ2V0VGFza3MgcmVzcG9uc2U6JywgZGF0YSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gZ2V0VGFza3MgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VGFza3NCeVByb2plY3QocHJvamVjdElkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGFza3NgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwcm9qZWN0IHRhc2tzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRhc2tCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzLyR7aWR9YCwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVUYXNrKHRhc2tEYXRhOiB7XG4gICAgcHJvamVjdElkOiBzdHJpbmc7XG4gICAgdGFzazogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgIHRhc2tUeXBlPzogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIHByaW9yaXR5OiBzdHJpbmc7XG4gICAgYXNzaWduZWRUbzogc3RyaW5nO1xuICAgIHJlcG9ydGVyOiBzdHJpbmc7XG4gICAgc3RhcnREYXRlPzogc3RyaW5nO1xuICAgIGV0YTogc3RyaW5nO1xuICAgIGVzdGltYXRlZEhvdXJzPzogbnVtYmVyO1xuICAgIGFjdHVhbEhvdXJzPzogbnVtYmVyO1xuICAgIHJlbWFyaz86IHN0cmluZztcbiAgICByb2FkQmxvY2s/OiBzdHJpbmc7XG4gICAgc3VwcG9ydE5lZWRlZD86IHN0cmluZztcbiAgICBsYWJlbHM/OiBzdHJpbmdbXTtcbiAgICBhdHRhY2htZW50cz86IHN0cmluZ1tdO1xuICAgIHJlbGF0ZWRUYXNrcz86IHN0cmluZ1tdO1xuICAgIHBhcmVudFRhc2s/OiBzdHJpbmc7XG4gICAgc3ByaW50Pzogc3RyaW5nO1xuICB9KSB7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIGNyZWF0ZVRhc2sgY2FsbGVkIHdpdGg6JywgdGFza0RhdGEpO1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdGFza3NgKTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gSGVhZGVyczonLCB0aGlzLmdldEF1dGhIZWFkZXIoKSk7XG4gICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIFJlcXVlc3QgQm9keTonLCBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSwgbnVsbCwgMikpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSBSZXNwb25zZSBvazonLCByZXNwb25zZS5vayk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSBFcnJvciByZXNwb25zZSBib2R5OicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZmV0Y2hFcnJvcikge1xuICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gRmV0Y2ggZXJyb3I6JywgZmV0Y2hFcnJvcik7XG4gICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVRhc2soaWQ6IHN0cmluZywgdGFza0RhdGE6IGFueSkge1xuICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUYXNrIGNhbGxlZCB3aXRoIElEOicsIGlkKTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBkYXRhOicsIHRhc2tEYXRhKTtcbiAgICBkZXZMb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdGFza3MvJHtpZH1gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcy8ke2lkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGRldkxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUYXNrIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgZGV2TG9nKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRhc2sgcmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZGV2RXJyb3IoJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBlcnJvciByZXNwb25zZTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZXZFcnJvcignQVBJIFNlcnZpY2UgLSB1cGRhdGVUYXNrIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVRhc2soaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdGFza3MvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVUYXNrU3RhdHVzKGlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcy8ke2lkfS9zdGF0dXNgLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN0YXR1cyB9KVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGFzc2lnblRhc2soaWQ6IHN0cmluZywgYXNzaWduZWRUbzogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcy8ke2lkfS9hc3NpZ25gLCB7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGFzc2lnbmVkVG8gfSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICAvLyBVc2VyIFRhc2sgQVBJc1xuICBhc3luYyBnZXRVc2VyVGFza3MocGFyYW1zPzoge1xuICAgIHVzZXJJZD86IHN0cmluZztcbiAgICBkYXRlPzogc3RyaW5nO1xuICAgIHR5cGVPZldvcms/OiBzdHJpbmc7XG4gICAgc3RhdHVzPzogc3RyaW5nO1xuICB9KSB7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHF1ZXJ5LmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlci10YXNrcz8ke3F1ZXJ5LnRvU3RyaW5nKCl9YCxcbiAgICAgIHsgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCkgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlVXNlclRhc2sodGFza0RhdGE6IHtcbiAgICBkYXRlOiBzdHJpbmc7XG4gICAgdHlwZU9mV29yazogc3RyaW5nO1xuICAgIHdvcmtEZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHByb2plY3Q6IHN0cmluZztcbiAgICB0YXNrOiBzdHJpbmc7XG4gICAgZnJlcXVlbmN5OiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgaG91cnNTcGVudD86IG51bWJlcjtcbiAgICBub3Rlcz86IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlci10YXNrc2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVVc2VyVGFzayhpZDogc3RyaW5nLCB0YXNrRGF0YTogYW55KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS91c2VyLXRhc2tzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RhdGEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlVXNlclRhc2soaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlci10YXNrcy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8vIERhc2hib2FyZCBBUElzXG4gIGFzeW5jIGdldERhc2hib2FyZFN0YXRzKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZGFzaGJvYXJkYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBnZXRQcm9qZWN0c1N1bW1hcnkoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9kYXNoYm9hcmQvcHJvamVjdHMtc3VtbWFyeWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGFza3NTdW1tYXJ5KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZGFzaGJvYXJkL3Rhc2tzLXN1bW1hcnlgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8vIE5ldyBEYXNoYm9hcmQgU3VtbWFyeSBBUEkgLSBTaW5nbGUgY2FsbCBmb3IgYWxsIGRhc2hib2FyZCBkYXRhXG4gIGFzeW5jIGdldERhc2hib2FyZFN1bW1hcnkocGFyYW1zPzogeyBkZXBhcnRtZW50Pzogc3RyaW5nIH0pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICBpZiAocGFyYW1zPy5kZXBhcnRtZW50KSB7XG4gICAgICAgIHF1ZXJ5LmFwcGVuZCgnZGVwYXJ0bWVudCcsIHBhcmFtcy5kZXBhcnRtZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXJsID0gYCR7QVBJX0JBU0VfVVJMfS9hcGkvZGFzaGJvYXJkL3N1bW1hcnkke3F1ZXJ5LnRvU3RyaW5nKCkgPyBgPyR7cXVlcnkudG9TdHJpbmcoKX1gIDogJyd9YDtcbiAgICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZGFzaGJvYXJkIHN1bW1hcnk6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGF2YWlsYWJsZSBkZXBhcnRtZW50cyBmb3IgYWRtaW4gdXNlcnNcbiAgYXN5bmMgZ2V0RGVwYXJ0bWVudHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2Rhc2hib2FyZC9kZXBhcnRtZW50c2AsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRldkVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZGVwYXJ0bWVudHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYXBpU2VydmljZSA9IG5ldyBBcGlTZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiY29uZmlnIiwiQVBJX0JBU0VfVVJMIiwiZ2V0QXBpVXJsIiwiZGV2TG9nIiwiYXJncyIsImZlYXR1cmVzIiwiZW5hYmxlRGVidWdMb2dnaW5nIiwiY29uc29sZSIsImxvZyIsImRldkVycm9yIiwiZXJyb3IiLCJBcGlTZXJ2aWNlIiwiZ2V0QXV0aEhlYWRlciIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhdXRoVmFsdWUiLCJzdGFydHNXaXRoIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXNwb25zZSIsInN0YXR1cyIsIm9rIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJoZWFkZXJzIiwiZW50cmllcyIsImVycm9yTWVzc2FnZSIsImVycm9yRGF0YSIsImpzb24iLCJtZXNzYWdlIiwibXNnIiwicGFyc2VFcnJvciIsImVycm9yVGV4dCIsInRleHQiLCJ0ZXN0IiwicmVtb3ZlSXRlbSIsIkVycm9yIiwiZGF0YSIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibG9naW4iLCJjcmVkZW50aWFscyIsImdldFByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlIiwiZ2V0VXNlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRVc2VyQnlJZCIsImlkIiwiZ2V0QXNzaWduYWJsZVVzZXJzIiwiZ2V0TXlUZWFtIiwiZ2V0UHJvamVjdHMiLCJwYXJhbXMiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImFwcGVuZCIsInRvU3RyaW5nIiwiZ2V0UHJvamVjdEJ5SWQiLCJ1cmwiLCJBdXRob3JpemF0aW9uIiwicmVzdWx0IiwiY3JlYXRlUHJvamVjdCIsInByb2plY3REYXRhIiwidXBkYXRlUHJvamVjdCIsImRlbGV0ZVByb2plY3QiLCJnZXRQcm9qZWN0VGFza3MiLCJwcm9qZWN0SWQiLCJhZGRUZWFtTWVtYmVyIiwidXNlcklkIiwicm9sZSIsInJlbW92ZVRlYW1NZW1iZXIiLCJ1cGRhdGVUZWFtTWVtYmVyUm9sZSIsImJ1bGtBZGRUZWFtTWVtYmVycyIsInRlYW1NZW1iZXJzIiwiYWRkVGVhbU1lbWJlcnNWaWFQcm9qZWN0VXBkYXRlIiwidXNlcklkcyIsImN1cnJlbnRQcm9qZWN0IiwiY3VycmVudFRlYW1NZW1iZXJzIiwiZXhpc3RpbmdVc2VySWRzIiwibWFwIiwiaXRlbSIsInVzZXIiLCJfaWQiLCJmaWx0ZXIiLCJ1cGRhdGVkVXNlcklkcyIsIlNldCIsInVwZGF0ZWRUZWFtTWVtYmVycyIsInVwZGF0ZURhdGEiLCJyZW1vdmVUZWFtTWVtYmVyVmlhUHJvamVjdFVwZGF0ZSIsImxlbmd0aCIsIm1lbWJlciIsImluZGV4IiwibWVtYmVyVXNlcklkIiwic2hvdWxkUmVtb3ZlIiwiaXRlbVVzZXJJZCIsInNob3VsZEtlZXAiLCJnZXRUYXNrcyIsImdldFRhc2tzQnlQcm9qZWN0IiwiZ2V0VGFza0J5SWQiLCJjcmVhdGVUYXNrIiwidGFza0RhdGEiLCJmZXRjaEVycm9yIiwidXBkYXRlVGFzayIsImRlbGV0ZVRhc2siLCJ1cGRhdGVUYXNrU3RhdHVzIiwiYXNzaWduVGFzayIsImFzc2lnbmVkVG8iLCJnZXRVc2VyVGFza3MiLCJjcmVhdGVVc2VyVGFzayIsInVwZGF0ZVVzZXJUYXNrIiwiZGVsZXRlVXNlclRhc2siLCJnZXREYXNoYm9hcmRTdGF0cyIsImdldFByb2plY3RzU3VtbWFyeSIsImdldFRhc2tzU3VtbWFyeSIsImdldERhc2hib2FyZFN1bW1hcnkiLCJkZXBhcnRtZW50IiwiZ2V0RGVwYXJ0bWVudHMiLCJhcGlTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});
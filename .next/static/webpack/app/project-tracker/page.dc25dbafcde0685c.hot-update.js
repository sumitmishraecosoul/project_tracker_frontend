"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/project-tracker/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiService: () => (/* binding */ apiService)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';\nclass ApiService {\n    getAuthHeader() {\n        const stored = localStorage.getItem('token') || '';\n        const authValue = stored ? stored.startsWith('Bearer ') ? stored : \"Bearer \".concat(stored) : '';\n        return {\n            'Content-Type': 'application/json',\n            ...authValue && {\n                'Authorization': authValue\n            }\n        };\n    }\n    async handleResponse(response) {\n        console.log('API Response Status:', response.status);\n        console.log('API Response OK:', response.ok);\n        console.log('API Response Headers:', Object.fromEntries(response.headers.entries()));\n        if (!response.ok) {\n            let errorMessage = 'API request failed';\n            try {\n                const errorData = await response.json();\n                console.log('API Error Data:', errorData);\n                errorMessage = errorData.message || errorData.error || errorData.msg || 'API request failed';\n            } catch (parseError) {\n                console.log('Failed to parse error response:', parseError);\n                const errorText = await response.text();\n                console.log('Raw error response:', errorText);\n                errorMessage = errorText || 'API request failed';\n            }\n            // If token invalid/expired, clear storage to force re-login\n            if (response.status === 401 || /token/i.test(errorMessage || '')) {\n                try {\n                    localStorage.removeItem('token');\n                    localStorage.removeItem('currentUser');\n                } catch (e) {}\n            }\n            throw new Error(errorMessage);\n        }\n        try {\n            const data = await response.json();\n            console.log('API Success Response:', data);\n            return data;\n        } catch (parseError) {\n            console.log('Failed to parse success response:', parseError);\n            throw new Error('Failed to parse API response');\n        }\n    }\n    // Authentication APIs\n    async register(userData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/register\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(userData)\n        });\n        return this.handleResponse(response);\n    }\n    async login(credentials) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/login\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(credentials)\n        });\n        return this.handleResponse(response);\n    }\n    async getProfile() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/profile\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async updateProfile(data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/profile\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    // User APIs\n    async getUsers() {\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users\"), {\n                headers: this.getAuthHeader()\n            });\n            const data = await this.handleResponse(response);\n            console.log('API Service - getUsers response:', data);\n            return Array.isArray(data) ? data : [];\n        } catch (error) {\n            console.error('API Service - getUsers error:', error);\n            throw error;\n        }\n    }\n    async getUserById(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/users/\").concat(id), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Project APIs\n    async getProjects(params) {\n        const query = new URLSearchParams();\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined) query.append(key, value.toString());\n            });\n        }\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects?\").concat(query.toString()), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectById(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(id), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async createProject(projectData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects\"), {\n            method: 'POST',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(projectData)\n        });\n        return this.handleResponse(response);\n    }\n    async updateProject(id, projectData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(id), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(projectData)\n        });\n        return this.handleResponse(response);\n    }\n    async deleteProject(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectTasks(projectId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/tasks\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Team Member Management APIs\n    async addTeamMember(projectId, userId, role) {\n        console.log('API Service - addTeamMember called with:', {\n            projectId,\n            userId,\n            role\n        });\n        console.log('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members\"));\n        console.log('API Service - Headers:', this.getAuthHeader());\n        console.log('API Service - Request Body:', JSON.stringify({\n            userId,\n            role\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    userId,\n                    role\n                })\n            });\n            console.log('API Service - addTeamMember response status:', response.status);\n            console.log('API Service - addTeamMember response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - addTeamMember error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            console.log('API Service - addTeamMember success result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - addTeamMember error:', error);\n            throw error;\n        }\n    }\n    async removeTeamMember(projectId, userId) {\n        console.log('API Service - removeTeamMember called with:', {\n            projectId,\n            userId\n        });\n        console.log('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId));\n        console.log('API Service - Headers:', this.getAuthHeader());\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId), {\n                method: 'DELETE',\n                headers: this.getAuthHeader()\n            });\n            console.log('API Service - removeTeamMember response status:', response.status);\n            console.log('API Service - removeTeamMember response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - removeTeamMember error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            console.log('API Service - removeTeamMember success result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - removeTeamMember error:', error);\n            throw error;\n        }\n    }\n    async updateTeamMemberRole(projectId, userId, role) {\n        console.log('API Service - updateTeamMemberRole called with:', {\n            projectId,\n            userId,\n            role\n        });\n        console.log('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId));\n        console.log('API Service - Headers:', this.getAuthHeader());\n        console.log('API Service - Request Body:', JSON.stringify({\n            role\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/\").concat(userId), {\n                method: 'PUT',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    role\n                })\n            });\n            console.log('API Service - updateTeamMemberRole response status:', response.status);\n            console.log('API Service - updateTeamMemberRole response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - updateTeamMemberRole error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            console.log('API Service - updateTeamMemberRole success result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - updateTeamMemberRole error:', error);\n            throw error;\n        }\n    }\n    async bulkAddTeamMembers(projectId, teamMembers) {\n        console.log('API Service - bulkAddTeamMembers called with:', {\n            projectId,\n            teamMembers\n        });\n        console.log('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/bulk\"));\n        console.log('API Service - Headers:', this.getAuthHeader());\n        console.log('API Service - Request Body:', JSON.stringify({\n            teamMembers\n        }, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/projects/\").concat(projectId, \"/team-members/bulk\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify({\n                    teamMembers\n                })\n            });\n            console.log('API Service - bulkAddTeamMembers response status:', response.status);\n            console.log('API Service - bulkAddTeamMembers response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - bulkAddTeamMembers error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const result = await this.handleResponse(response);\n            console.log('API Service - bulkAddTeamMembers success result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - bulkAddTeamMembers error:', error);\n            throw error;\n        }\n    }\n    // Fallback method using project update API\n    async addTeamMembersViaProjectUpdate(projectId, userIds) {\n        console.log('API Service - addTeamMembersViaProjectUpdate called with:', {\n            projectId,\n            userIds\n        });\n        try {\n            // First get the current project data\n            const currentProject = await this.getProjectById(projectId);\n            console.log('API Service - Current project data:', currentProject);\n            // Get current teamMembers array (not assignedTo)\n            const currentTeamMembers = currentProject.teamMembers || [];\n            console.log('API Service - Current teamMembers:', currentTeamMembers);\n            // Extract existing user IDs from teamMembers\n            const existingUserIds = currentTeamMembers.map((item)=>{\n                if (item && typeof item === 'object' && item.user && item.user._id) {\n                    return item.user._id;\n                }\n                return null;\n            }).filter((id)=>id !== null);\n            console.log('API Service - Existing team member user IDs:', existingUserIds);\n            // Add new user IDs to the array (avoiding duplicates)\n            const updatedUserIds = [\n                ...new Set([\n                    ...existingUserIds,\n                    ...userIds\n                ])\n            ];\n            console.log('API Service - Updated user IDs:', updatedUserIds);\n            // Create teamMembers array with proper structure\n            const updatedTeamMembers = updatedUserIds.map((userId)=>({\n                    user: userId,\n                    role: 'member' // default role\n                }));\n            // Update the project with new teamMembers array\n            const updateData = {\n                ...currentProject,\n                teamMembers: updatedTeamMembers\n            };\n            console.log('API Service - Update data:', updateData);\n            const result = await this.updateProject(projectId, updateData);\n            console.log('API Service - Project update result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - addTeamMembersViaProjectUpdate error:', error);\n            throw error;\n        }\n    }\n    async removeTeamMemberViaProjectUpdate(projectId, userId) {\n        console.log('API Service - removeTeamMemberViaProjectUpdate called with:', {\n            projectId,\n            userId\n        });\n        try {\n            // First get the current project data\n            const currentProject = await this.getProjectById(projectId);\n            console.log('API Service - Current project data:', currentProject);\n            // Get current teamMembers array (not assignedTo)\n            const currentTeamMembers = currentProject.teamMembers || [];\n            console.log('API Service - Current teamMembers before removal:', currentTeamMembers);\n            console.log('API Service - Current teamMembers count before removal:', currentTeamMembers.length);\n            // Log each team member for debugging\n            currentTeamMembers.forEach((member, index)=>{\n                const memberUserId = typeof member.user === 'string' ? member.user : member.user._id;\n                console.log(\"API Service - Team member \".concat(index, \":\"), {\n                    member,\n                    memberUserId,\n                    shouldRemove: memberUserId === userId\n                });\n            });\n            // Remove the user ID from the teamMembers array\n            const updatedTeamMembers = currentTeamMembers.filter((item)=>{\n                if (item && typeof item === 'object' && item.user) {\n                    const itemUserId = typeof item.user === 'string' ? item.user : item.user._id;\n                    const shouldKeep = itemUserId !== userId;\n                    console.log(\"API Service - Filtering team member: \".concat(itemUserId, \" !== \").concat(userId, \" = \").concat(shouldKeep));\n                    return shouldKeep;\n                }\n                console.log('API Service - Keeping item (no user property):', item);\n                return true;\n            });\n            console.log('API Service - Updated teamMembers after removal:', updatedTeamMembers);\n            console.log('API Service - Updated teamMembers count after removal:', updatedTeamMembers.length);\n            console.log('API Service - Removed count:', currentTeamMembers.length - updatedTeamMembers.length);\n            // Update the project with new teamMembers array\n            const updateData = {\n                ...currentProject,\n                teamMembers: updatedTeamMembers\n            };\n            console.log('API Service - Update data:', updateData);\n            const result = await this.updateProject(projectId, updateData);\n            console.log('API Service - Project update result:', result);\n            return result;\n        } catch (error) {\n            console.error('API Service - removeTeamMemberViaProjectUpdate error:', error);\n            throw error;\n        }\n    }\n    // Task APIs\n    async getTasks() {\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks\"), {\n                headers: this.getAuthHeader()\n            });\n            const data = await this.handleResponse(response);\n            console.log('API Service - getTasks response:', data);\n            return Array.isArray(data) ? data : [];\n        } catch (error) {\n            console.error('API Service - getTasks error:', error);\n            throw error;\n        }\n    }\n    async getTasksByProject(projectId) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks?projectId=\").concat(projectId), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getTaskById(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async createTask(taskData) {\n        console.log('API Service - createTask called with:', taskData);\n        console.log('API Service - URL:', \"\".concat(API_BASE_URL, \"/api/tasks\"));\n        console.log('API Service - Headers:', this.getAuthHeader());\n        console.log('API Service - Request Body:', JSON.stringify(taskData, null, 2));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks\"), {\n                method: 'POST',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify(taskData)\n            });\n            console.log('API Service - Response status:', response.status);\n            console.log('API Service - Response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - Error response body:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            return this.handleResponse(response);\n        } catch (fetchError) {\n            console.error('API Service - Fetch error:', fetchError);\n            throw fetchError;\n        }\n    }\n    async updateTask(id, taskData) {\n        console.log('API Service - updateTask called with ID:', id);\n        console.log('API Service - updateTask data:', taskData);\n        console.log('API Service - updateTask URL:', \"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n                method: 'PUT',\n                headers: this.getAuthHeader(),\n                body: JSON.stringify(taskData)\n            });\n            console.log('API Service - updateTask response status:', response.status);\n            console.log('API Service - updateTask response ok:', response.ok);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('API Service - updateTask error response:', errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            return this.handleResponse(response);\n        } catch (error) {\n            console.error('API Service - updateTask error:', error);\n            throw error;\n        }\n    }\n    async deleteTask(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async updateTaskStatus(id, status) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id, \"/status\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify({\n                status\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async assignTask(id, assignedTo) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/tasks/\").concat(id, \"/assign\"), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify({\n                assignedTo\n            })\n        });\n        return this.handleResponse(response);\n    }\n    // User Task APIs\n    async getUserTasks(params) {\n        const query = new URLSearchParams();\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined) query.append(key, value);\n            });\n        }\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks?\").concat(query.toString()), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async createUserTask(taskData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks\"), {\n            method: 'POST',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(taskData)\n        });\n        return this.handleResponse(response);\n    }\n    async updateUserTask(id, taskData) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks/\").concat(id), {\n            method: 'PUT',\n            headers: this.getAuthHeader(),\n            body: JSON.stringify(taskData)\n        });\n        return this.handleResponse(response);\n    }\n    async deleteUserTask(id) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/user-tasks/\").concat(id), {\n            method: 'DELETE',\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    // Dashboard APIs\n    async getDashboardStats() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getProjectsSummary() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/projects-summary\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n    async getTasksSummary() {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/tasks-summary\"), {\n            headers: this.getAuthHeader()\n        });\n        return this.handleResponse(response);\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU0sR0FBZ0IsT0FBYnBDLGNBQWEsbUJBQWlCO1lBQzVEbUIsU0FBUyxJQUFJLENBQUNkLGFBQWE7UUFDN0I7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtJQUVBLE1BQU1xRyxxQkFBcUI7UUFDekIsTUFBTXJHLFdBQVcsTUFBTXdCLE1BQU0sR0FBZ0IsT0FBYnBDLGNBQWEsb0NBQWtDO1lBQzdFbUIsU0FBUyxJQUFJLENBQUNkLGFBQWE7UUFDN0I7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtJQUVBLE1BQU1zRyxrQkFBa0I7UUFDdEIsTUFBTXRHLFdBQVcsTUFBTXdCLE1BQU0sR0FBZ0IsT0FBYnBDLGNBQWEsaUNBQStCO1lBQzFFbUIsU0FBUyxJQUFJLENBQUNkLGFBQWE7UUFDN0I7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtBQUNGO0FBRU8sTUFBTXVHLGFBQWEsSUFBSS9HLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU3VtaXQgTWlzaHJhXFxPbmVEcml2ZSAtIEVjb1NvdWwgSG9tZVxcRG9jdW1lbnRzXFxQcm9qZWN0IHRyYWNrZXJyXFxQcm9qZWN0IHRyYWNrZXJcXGxpYlxcYXBpLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAwJztcblxuaW50ZXJmYWNlIFVzZXIge1xuICBfaWQ6IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcm9sZTogc3RyaW5nO1xuICBkZXBhcnRtZW50OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUYXNrIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGlkOiBzdHJpbmc7XG4gIHByb2plY3RJZDogc3RyaW5nO1xuICB0YXNrOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB0YXNrVHlwZT86IHN0cmluZztcbiAgcHJpb3JpdHk6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGFzc2lnbmVkVG86IHtcbiAgICBfaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgfTtcbiAgcmVwb3J0ZXI6IHtcbiAgICBfaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgfTtcbiAgc3RhcnREYXRlPzogc3RyaW5nO1xuICBldGE6IHN0cmluZztcbiAgZXN0aW1hdGVkSG91cnM/OiBudW1iZXI7XG4gIGFjdHVhbEhvdXJzPzogbnVtYmVyO1xuICByZW1hcms/OiBzdHJpbmc7XG4gIHJvYWRCbG9jaz86IHN0cmluZztcbiAgc3VwcG9ydE5lZWRlZD86IHN0cmluZztcbiAgbGFiZWxzPzogc3RyaW5nW107XG4gIGF0dGFjaG1lbnRzPzogc3RyaW5nW107XG4gIHJlbGF0ZWRUYXNrcz86IHN0cmluZ1tdO1xuICBwYXJlbnRUYXNrPzogc3RyaW5nO1xuICBzcHJpbnQ/OiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICB1cGRhdGVkQXQ6IHN0cmluZztcbn1cblxuY2xhc3MgQXBpU2VydmljZSB7XG4gIHByaXZhdGUgZ2V0QXV0aEhlYWRlcigpIHtcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSB8fCAnJztcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBzdG9yZWRcbiAgICAgID8gc3RvcmVkLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSA/IHN0b3JlZCA6IGBCZWFyZXIgJHtzdG9yZWR9YFxuICAgICAgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLihhdXRoVmFsdWUgJiYgeyAnQXV0aG9yaXphdGlvbic6IGF1dGhWYWx1ZSB9KVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlOiBSZXNwb25zZSkge1xuICAgIGNvbnNvbGUubG9nKCdBUEkgUmVzcG9uc2UgU3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBSZXNwb25zZSBPSzonLCByZXNwb25zZS5vayk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBSZXNwb25zZSBIZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnQVBJIHJlcXVlc3QgZmFpbGVkJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0FQSSBFcnJvciBEYXRhOicsIGVycm9yRGF0YSk7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBlcnJvckRhdGEubXNnIHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIGVycm9yIHJlc3BvbnNlOicsIHBhcnNlRXJyb3IpO1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSYXcgZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JUZXh0IHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB0b2tlbiBpbnZhbGlkL2V4cGlyZWQsIGNsZWFyIHN0b3JhZ2UgdG8gZm9yY2UgcmUtbG9naW5cbiAgICAgIGlmIChcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHxcbiAgICAgICAgL3Rva2VuL2kudGVzdChlcnJvck1lc3NhZ2UgfHwgJycpXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndG9rZW4nKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY3VycmVudFVzZXInKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTdWNjZXNzIFJlc3BvbnNlOicsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBzdWNjZXNzIHJlc3BvbnNlOicsIHBhcnNlRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgQVBJIHJlc3BvbnNlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXV0aGVudGljYXRpb24gQVBJc1xuICBhc3luYyByZWdpc3Rlcih1c2VyRGF0YToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIGRlcGFydG1lbnQ6IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYXV0aC9yZWdpc3RlcmAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBsb2dpbihjcmVkZW50aWFsczogeyBlbWFpbDogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2F1dGgvbG9naW5gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY3JlZGVudGlhbHMpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvZmlsZSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2F1dGgvcHJvZmlsZWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZShkYXRhOiB7IG5hbWU/OiBzdHJpbmc7IGRlcGFydG1lbnQ/OiBzdHJpbmcgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYXV0aC9wcm9maWxlYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICAvLyBVc2VyIEFQSXNcbiAgYXN5bmMgZ2V0VXNlcnMoKTogUHJvbWlzZTxVc2VyW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS91c2Vyc2AsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gZ2V0VXNlcnMgcmVzcG9uc2U6JywgZGF0YSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBnZXRVc2VycyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRVc2VyQnlJZChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS91c2Vycy8ke2lkfWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gUHJvamVjdCBBUElzXG4gIGFzeW5jIGdldFByb2plY3RzKHBhcmFtcz86IHtcbiAgICBwYWdlPzogbnVtYmVyO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBxdWVyeS5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHM/JHtxdWVyeS50b1N0cmluZygpfWAsXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb2plY3RCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7aWR9YCwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVQcm9qZWN0KHByb2plY3REYXRhOiB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIHByaW9yaXR5OiBzdHJpbmc7XG4gICAgc3RhcnREYXRlOiBzdHJpbmc7XG4gICAgZHVlRGF0ZTogc3RyaW5nO1xuICAgIGFzc2lnbmVkVG8/OiBzdHJpbmdbXTtcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJvamVjdERhdGEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvamVjdChpZDogc3RyaW5nLCBwcm9qZWN0RGF0YTogYW55KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2plY3REYXRhKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVByb2plY3QoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBnZXRQcm9qZWN0VGFza3MocHJvamVjdElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7cHJvamVjdElkfS90YXNrc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gVGVhbSBNZW1iZXIgTWFuYWdlbWVudCBBUElzXG4gIGFzeW5jIGFkZFRlYW1NZW1iZXIocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nLCByb2xlPzogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlciBjYWxsZWQgd2l0aDonLCB7IHByb2plY3RJZCwgdXNlcklkLCByb2xlIH0pO1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFVSTDonLCBgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGVhbS1tZW1iZXJzYCk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gSGVhZGVyczonLCB0aGlzLmdldEF1dGhIZWFkZXIoKSk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gUmVxdWVzdCBCb2R5OicsIEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCByb2xlIH0sIG51bGwsIDIpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGVhbS1tZW1iZXJzYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCByb2xlIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlciByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIGFkZFRlYW1NZW1iZXIgcmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIGFkZFRlYW1NZW1iZXIgc3VjY2VzcyByZXN1bHQ6JywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlciBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVUZWFtTWVtYmVyKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIHJlbW92ZVRlYW1NZW1iZXIgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHVzZXJJZCB9KTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy8ke3VzZXJJZH1gKTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBIZWFkZXJzOicsIHRoaXMuZ2V0QXV0aEhlYWRlcigpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGVhbS1tZW1iZXJzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSByZW1vdmVUZWFtTWVtYmVyIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlciByZXNwb25zZSBvazonLCByZXNwb25zZS5vayk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgU2VydmljZSAtIHJlbW92ZVRlYW1NZW1iZXIgZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlciBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSByZW1vdmVUZWFtTWVtYmVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVRlYW1NZW1iZXJSb2xlKHByb2plY3RJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGVhbU1lbWJlclJvbGUgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHVzZXJJZCwgcm9sZSB9KTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy8ke3VzZXJJZH1gKTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBIZWFkZXJzOicsIHRoaXMuZ2V0QXV0aEhlYWRlcigpKTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBSZXF1ZXN0IEJvZHk6JywgSlNPTi5zdHJpbmdpZnkoeyByb2xlIH0sIG51bGwsIDIpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vdGVhbS1tZW1iZXJzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcm9sZSB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRlYW1NZW1iZXJSb2xlIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGVhbU1lbWJlclJvbGUgcmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSB1cGRhdGVUZWFtTWVtYmVyUm9sZSBlcnJvciByZXNwb25zZTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUZWFtTWVtYmVyUm9sZSBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSB1cGRhdGVUZWFtTWVtYmVyUm9sZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBidWxrQWRkVGVhbU1lbWJlcnMocHJvamVjdElkOiBzdHJpbmcsIHRlYW1NZW1iZXJzOiBBcnJheTx7IHVzZXJJZDogc3RyaW5nOyByb2xlPzogc3RyaW5nIH0+KSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIGNhbGxlZCB3aXRoOicsIHsgcHJvamVjdElkLCB0ZWFtTWVtYmVycyB9KTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBVUkw6JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3RlYW0tbWVtYmVycy9idWxrYCk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gSGVhZGVyczonLCB0aGlzLmdldEF1dGhIZWFkZXIoKSk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gUmVxdWVzdCBCb2R5OicsIEpTT04uc3RyaW5naWZ5KHsgdGVhbU1lbWJlcnMgfSwgbnVsbCwgMikpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Byb2plY3RzLyR7cHJvamVjdElkfS90ZWFtLW1lbWJlcnMvYnVsa2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRlYW1NZW1iZXJzIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIHJlc3BvbnNlIG9rOicsIHJlc3BvbnNlLm9rKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBTZXJ2aWNlIC0gYnVsa0FkZFRlYW1NZW1iZXJzIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIGJ1bGtBZGRUZWFtTWVtYmVycyBzdWNjZXNzIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBidWxrQWRkVGVhbU1lbWJlcnMgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbGJhY2sgbWV0aG9kIHVzaW5nIHByb2plY3QgdXBkYXRlIEFQSVxuICBhc3luYyBhZGRUZWFtTWVtYmVyc1ZpYVByb2plY3RVcGRhdGUocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZHM6IHN0cmluZ1tdKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gYWRkVGVhbU1lbWJlcnNWaWFQcm9qZWN0VXBkYXRlIGNhbGxlZCB3aXRoOicsIHsgcHJvamVjdElkLCB1c2VySWRzIH0pO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBnZXQgdGhlIGN1cnJlbnQgcHJvamVjdCBkYXRhXG4gICAgICBjb25zdCBjdXJyZW50UHJvamVjdCA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdEJ5SWQocHJvamVjdElkKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIEN1cnJlbnQgcHJvamVjdCBkYXRhOicsIGN1cnJlbnRQcm9qZWN0KTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGN1cnJlbnQgdGVhbU1lbWJlcnMgYXJyYXkgKG5vdCBhc3NpZ25lZFRvKVxuICAgICAgY29uc3QgY3VycmVudFRlYW1NZW1iZXJzID0gY3VycmVudFByb2plY3QudGVhbU1lbWJlcnMgfHwgW107XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBDdXJyZW50IHRlYW1NZW1iZXJzOicsIGN1cnJlbnRUZWFtTWVtYmVycyk7XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgZXhpc3RpbmcgdXNlciBJRHMgZnJvbSB0ZWFtTWVtYmVyc1xuICAgICAgY29uc3QgZXhpc3RpbmdVc2VySWRzID0gY3VycmVudFRlYW1NZW1iZXJzLm1hcCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtLnVzZXIgJiYgaXRlbS51c2VyLl9pZCkge1xuICAgICAgICAgIHJldHVybiBpdGVtLnVzZXIuX2lkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSkuZmlsdGVyKChpZDogc3RyaW5nIHwgbnVsbCkgPT4gaWQgIT09IG51bGwpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBFeGlzdGluZyB0ZWFtIG1lbWJlciB1c2VyIElEczonLCBleGlzdGluZ1VzZXJJZHMpO1xuICAgICAgXG4gICAgICAvLyBBZGQgbmV3IHVzZXIgSURzIHRvIHRoZSBhcnJheSAoYXZvaWRpbmcgZHVwbGljYXRlcylcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VySWRzID0gWy4uLm5ldyBTZXQoWy4uLmV4aXN0aW5nVXNlcklkcywgLi4udXNlcklkc10pXTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFVwZGF0ZWQgdXNlciBJRHM6JywgdXBkYXRlZFVzZXJJZHMpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGVhbU1lbWJlcnMgYXJyYXkgd2l0aCBwcm9wZXIgc3RydWN0dXJlXG4gICAgICBjb25zdCB1cGRhdGVkVGVhbU1lbWJlcnMgPSB1cGRhdGVkVXNlcklkcy5tYXAodXNlcklkID0+ICh7XG4gICAgICAgIHVzZXI6IHVzZXJJZCxcbiAgICAgICAgcm9sZTogJ21lbWJlcicgLy8gZGVmYXVsdCByb2xlXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvamVjdCB3aXRoIG5ldyB0ZWFtTWVtYmVycyBhcnJheVxuICAgICAgY29uc3QgdXBkYXRlRGF0YSA9IHtcbiAgICAgICAgLi4uY3VycmVudFByb2plY3QsXG4gICAgICAgIHRlYW1NZW1iZXJzOiB1cGRhdGVkVGVhbU1lbWJlcnNcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFVwZGF0ZSBkYXRhOicsIHVwZGF0ZURhdGEpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwZGF0ZVByb2plY3QocHJvamVjdElkLCB1cGRhdGVEYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFByb2plY3QgdXBkYXRlIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBhZGRUZWFtTWVtYmVyc1ZpYVByb2plY3RVcGRhdGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVtb3ZlVGVhbU1lbWJlclZpYVByb2plY3RVcGRhdGUocHJvamVjdElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gcmVtb3ZlVGVhbU1lbWJlclZpYVByb2plY3RVcGRhdGUgY2FsbGVkIHdpdGg6JywgeyBwcm9qZWN0SWQsIHVzZXJJZCB9KTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgZ2V0IHRoZSBjdXJyZW50IHByb2plY3QgZGF0YVxuICAgICAgY29uc3QgY3VycmVudFByb2plY3QgPSBhd2FpdCB0aGlzLmdldFByb2plY3RCeUlkKHByb2plY3RJZCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBDdXJyZW50IHByb2plY3QgZGF0YTonLCBjdXJyZW50UHJvamVjdCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjdXJyZW50IHRlYW1NZW1iZXJzIGFycmF5IChub3QgYXNzaWduZWRUbylcbiAgICAgIGNvbnN0IGN1cnJlbnRUZWFtTWVtYmVycyA9IGN1cnJlbnRQcm9qZWN0LnRlYW1NZW1iZXJzIHx8IFtdO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gQ3VycmVudCB0ZWFtTWVtYmVycyBiZWZvcmUgcmVtb3ZhbDonLCBjdXJyZW50VGVhbU1lbWJlcnMpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gQ3VycmVudCB0ZWFtTWVtYmVycyBjb3VudCBiZWZvcmUgcmVtb3ZhbDonLCBjdXJyZW50VGVhbU1lbWJlcnMubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGVhY2ggdGVhbSBtZW1iZXIgZm9yIGRlYnVnZ2luZ1xuICAgICAgY3VycmVudFRlYW1NZW1iZXJzLmZvckVhY2goKG1lbWJlciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbWVtYmVyVXNlcklkID0gdHlwZW9mIG1lbWJlci51c2VyID09PSAnc3RyaW5nJyA/IG1lbWJlci51c2VyIDogbWVtYmVyLnVzZXIuX2lkO1xuICAgICAgICBjb25zb2xlLmxvZyhgQVBJIFNlcnZpY2UgLSBUZWFtIG1lbWJlciAke2luZGV4fTpgLCB7XG4gICAgICAgICAgbWVtYmVyLFxuICAgICAgICAgIG1lbWJlclVzZXJJZCxcbiAgICAgICAgICBzaG91bGRSZW1vdmU6IG1lbWJlclVzZXJJZCA9PT0gdXNlcklkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSB0aGUgdXNlciBJRCBmcm9tIHRoZSB0ZWFtTWVtYmVycyBhcnJheVxuICAgICAgY29uc3QgdXBkYXRlZFRlYW1NZW1iZXJzID0gY3VycmVudFRlYW1NZW1iZXJzLmZpbHRlcigoaXRlbTogYW55KSA9PiB7XG4gICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtLnVzZXIpIHtcbiAgICAgICAgICBjb25zdCBpdGVtVXNlcklkID0gdHlwZW9mIGl0ZW0udXNlciA9PT0gJ3N0cmluZycgPyBpdGVtLnVzZXIgOiBpdGVtLnVzZXIuX2lkO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEtlZXAgPSBpdGVtVXNlcklkICE9PSB1c2VySWQ7XG4gICAgICAgICAgY29uc29sZS5sb2coYEFQSSBTZXJ2aWNlIC0gRmlsdGVyaW5nIHRlYW0gbWVtYmVyOiAke2l0ZW1Vc2VySWR9ICE9PSAke3VzZXJJZH0gPSAke3Nob3VsZEtlZXB9YCk7XG4gICAgICAgICAgcmV0dXJuIHNob3VsZEtlZXA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gS2VlcGluZyBpdGVtIChubyB1c2VyIHByb3BlcnR5KTonLCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gVXBkYXRlZCB0ZWFtTWVtYmVycyBhZnRlciByZW1vdmFsOicsIHVwZGF0ZWRUZWFtTWVtYmVycyk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBVcGRhdGVkIHRlYW1NZW1iZXJzIGNvdW50IGFmdGVyIHJlbW92YWw6JywgdXBkYXRlZFRlYW1NZW1iZXJzLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBSZW1vdmVkIGNvdW50OicsIGN1cnJlbnRUZWFtTWVtYmVycy5sZW5ndGggLSB1cGRhdGVkVGVhbU1lbWJlcnMubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9qZWN0IHdpdGggbmV3IHRlYW1NZW1iZXJzIGFycmF5XG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0ge1xuICAgICAgICAuLi5jdXJyZW50UHJvamVjdCxcbiAgICAgICAgdGVhbU1lbWJlcnM6IHVwZGF0ZWRUZWFtTWVtYmVyc1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gVXBkYXRlIGRhdGE6JywgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHVwZGF0ZURhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gUHJvamVjdCB1cGRhdGUgcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgU2VydmljZSAtIHJlbW92ZVRlYW1NZW1iZXJWaWFQcm9qZWN0VXBkYXRlIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRhc2sgQVBJc1xuICBhc3luYyBnZXRUYXNrcygpOiBQcm9taXNlPFRhc2tbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSBnZXRUYXNrcyByZXNwb25zZTonLCBkYXRhKTtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgU2VydmljZSAtIGdldFRhc2tzIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRhc2tzQnlQcm9qZWN0KHByb2plY3RJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcz9wcm9qZWN0SWQ9JHtwcm9qZWN0SWR9YCwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBnZXRUYXNrQnlJZChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcy8ke2lkfWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlVGFzayh0YXNrRGF0YToge1xuICAgIHByb2plY3RJZDogc3RyaW5nO1xuICAgIHRhc2s6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICB0YXNrVHlwZT86IHN0cmluZztcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBwcmlvcml0eTogc3RyaW5nO1xuICAgIGFzc2lnbmVkVG86IHN0cmluZztcbiAgICByZXBvcnRlcjogc3RyaW5nO1xuICAgIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgICBldGE6IHN0cmluZztcbiAgICBlc3RpbWF0ZWRIb3Vycz86IG51bWJlcjtcbiAgICBhY3R1YWxIb3Vycz86IG51bWJlcjtcbiAgICByZW1hcms/OiBzdHJpbmc7XG4gICAgcm9hZEJsb2NrPzogc3RyaW5nO1xuICAgIHN1cHBvcnROZWVkZWQ/OiBzdHJpbmc7XG4gICAgbGFiZWxzPzogc3RyaW5nW107XG4gICAgYXR0YWNobWVudHM/OiBzdHJpbmdbXTtcbiAgICByZWxhdGVkVGFza3M/OiBzdHJpbmdbXTtcbiAgICBwYXJlbnRUYXNrPzogc3RyaW5nO1xuICAgIHNwcmludD86IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIGNyZWF0ZVRhc2sgY2FsbGVkIHdpdGg6JywgdGFza0RhdGEpO1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFVSTDonLCBgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrc2ApO1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIEhlYWRlcnM6JywgdGhpcy5nZXRBdXRoSGVhZGVyKCkpO1xuICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFJlcXVlc3QgQm9keTonLCBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSwgbnVsbCwgMikpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gUmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBFcnJvciByZXNwb25zZSBib2R5OicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZmV0Y2hFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSBGZXRjaCBlcnJvcjonLCBmZXRjaEVycm9yKTtcbiAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlVGFzayhpZDogc3RyaW5nLCB0YXNrRGF0YTogYW55KSB7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBjYWxsZWQgd2l0aCBJRDonLCBpZCk7XG4gICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBkYXRhOicsIHRhc2tEYXRhKTtcbiAgICBjb25zb2xlLmxvZygnQVBJIFNlcnZpY2UgLSB1cGRhdGVUYXNrIFVSTDonLCBgJHtBUElfQkFTRV9VUkx9L2FwaS90YXNrcy8ke2lkfWApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RhdGEpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEkgU2VydmljZSAtIHVwZGF0ZVRhc2sgcmVzcG9uc2Ugb2s6JywgcmVzcG9uc2Uub2spO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJIFNlcnZpY2UgLSB1cGRhdGVUYXNrIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBTZXJ2aWNlIC0gdXBkYXRlVGFzayBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWxldGVUYXNrKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Rhc2tzLyR7aWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlVGFza1N0YXR1cyhpZDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdGFza3MvJHtpZH0vc3RhdHVzYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdGF0dXMgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICBhc3luYyBhc3NpZ25UYXNrKGlkOiBzdHJpbmcsIGFzc2lnbmVkVG86IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdGFza3MvJHtpZH0vYXNzaWduYCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhc3NpZ25lZFRvIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgLy8gVXNlciBUYXNrIEFQSXNcbiAgYXN5bmMgZ2V0VXNlclRhc2tzKHBhcmFtcz86IHtcbiAgICB1c2VySWQ/OiBzdHJpbmc7XG4gICAgZGF0ZT86IHN0cmluZztcbiAgICB0eXBlT2ZXb3JrPzogc3RyaW5nO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgfSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBxdWVyeS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke0FQSV9CQVNFX1VSTH0vYXBpL3VzZXItdGFza3M/JHtxdWVyeS50b1N0cmluZygpfWAsXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVVzZXJUYXNrKHRhc2tEYXRhOiB7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIHR5cGVPZldvcms6IHN0cmluZztcbiAgICB3b3JrRGVzY3JpcHRpb246IHN0cmluZztcbiAgICBwcm9qZWN0OiBzdHJpbmc7XG4gICAgdGFzazogc3RyaW5nO1xuICAgIGZyZXF1ZW5jeTogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGhvdXJzU3BlbnQ/OiBudW1iZXI7XG4gICAgbm90ZXM/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3VzZXItdGFza3NgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RhdGEpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlVXNlclRhc2soaWQ6IHN0cmluZywgdGFza0RhdGE6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlci10YXNrcy8ke2lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVVzZXJUYXNrKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3VzZXItdGFza3MvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cblxuICAvLyBEYXNoYm9hcmQgQVBJc1xuICBhc3luYyBnZXREYXNoYm9hcmRTdGF0cygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2Rhc2hib2FyZGAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0QXV0aEhlYWRlcigpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvamVjdHNTdW1tYXJ5KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZGFzaGJvYXJkL3Byb2plY3RzLXN1bW1hcnlgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEF1dGhIZWFkZXIoKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRhc2tzU3VtbWFyeSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2Rhc2hib2FyZC90YXNrcy1zdW1tYXJ5YCwge1xuICAgICAgaGVhZGVyczogdGhpcy5nZXRBdXRoSGVhZGVyKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFwaVNlcnZpY2UgPSBuZXcgQXBpU2VydmljZSgpO1xuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQXBpU2VydmljZSIsImdldEF1dGhIZWFkZXIiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aFZhbHVlIiwic3RhcnRzV2l0aCIsImhhbmRsZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwib2siLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImhlYWRlcnMiLCJlbnRyaWVzIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JEYXRhIiwianNvbiIsIm1lc3NhZ2UiLCJlcnJvciIsIm1zZyIsInBhcnNlRXJyb3IiLCJlcnJvclRleHQiLCJ0ZXh0IiwidGVzdCIsInJlbW92ZUl0ZW0iLCJFcnJvciIsImRhdGEiLCJyZWdpc3RlciIsInVzZXJEYXRhIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsImdldFVzZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0VXNlckJ5SWQiLCJpZCIsImdldFByb2plY3RzIiwicGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJhcHBlbmQiLCJ0b1N0cmluZyIsImdldFByb2plY3RCeUlkIiwiY3JlYXRlUHJvamVjdCIsInByb2plY3REYXRhIiwidXBkYXRlUHJvamVjdCIsImRlbGV0ZVByb2plY3QiLCJnZXRQcm9qZWN0VGFza3MiLCJwcm9qZWN0SWQiLCJhZGRUZWFtTWVtYmVyIiwidXNlcklkIiwicm9sZSIsInJlc3VsdCIsInJlbW92ZVRlYW1NZW1iZXIiLCJ1cGRhdGVUZWFtTWVtYmVyUm9sZSIsImJ1bGtBZGRUZWFtTWVtYmVycyIsInRlYW1NZW1iZXJzIiwiYWRkVGVhbU1lbWJlcnNWaWFQcm9qZWN0VXBkYXRlIiwidXNlcklkcyIsImN1cnJlbnRQcm9qZWN0IiwiY3VycmVudFRlYW1NZW1iZXJzIiwiZXhpc3RpbmdVc2VySWRzIiwibWFwIiwiaXRlbSIsInVzZXIiLCJfaWQiLCJmaWx0ZXIiLCJ1cGRhdGVkVXNlcklkcyIsIlNldCIsInVwZGF0ZWRUZWFtTWVtYmVycyIsInVwZGF0ZURhdGEiLCJyZW1vdmVUZWFtTWVtYmVyVmlhUHJvamVjdFVwZGF0ZSIsImxlbmd0aCIsIm1lbWJlciIsImluZGV4IiwibWVtYmVyVXNlcklkIiwic2hvdWxkUmVtb3ZlIiwiaXRlbVVzZXJJZCIsInNob3VsZEtlZXAiLCJnZXRUYXNrcyIsImdldFRhc2tzQnlQcm9qZWN0IiwiZ2V0VGFza0J5SWQiLCJjcmVhdGVUYXNrIiwidGFza0RhdGEiLCJmZXRjaEVycm9yIiwidXBkYXRlVGFzayIsImRlbGV0ZVRhc2siLCJ1cGRhdGVUYXNrU3RhdHVzIiwiYXNzaWduVGFzayIsImFzc2lnbmVkVG8iLCJnZXRVc2VyVGFza3MiLCJjcmVhdGVVc2VyVGFzayIsInVwZGF0ZVVzZXJUYXNrIiwiZGVsZXRlVXNlclRhc2siLCJnZXREYXNoYm9hcmRTdGF0cyIsImdldFByb2plY3RzU3VtbWFyeSIsImdldFRhc2tzU3VtbWFyeSIsImFwaVNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});